name: Deploy to AWS EKS

on:
  push:
    branches: ["**"]        # Any branch
  pull_request:
    branches: ["**"]
  workflow_dispatch:

env:
  CLUSTER_NAME: our-eks-cluster
  AWS_REGION: eu-west-2
  ECR_REPOSITORY: nginx-app
  IMAGE_TAG: latest

jobs:
  terraform:
    name: Provision EKS with Terraform
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        run: terraform init

      - name: Terraform Plan
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan

      # Export required Terraform outputs for later jobs
      - name: Export Terraform outputs
        run: terraform output -json > tf-outputs.json

      - name: Upload TF outputs artifact
        uses: actions/upload-artifact@v4
        with:
          name: tf-outputs
          path: tf-outputs.json

  build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: terraform

    outputs:
      image_uri: ${{ steps.build_push.outputs.image_uri }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, Tag, and Push Image to ECR
        id: build_push
        run: |
          IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
          echo "Building and pushing image: $IMAGE_URI"
          docker build -t "$IMAGE_URI" .
          docker push "$IMAGE_URI"
          echo "image_uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"

  deploy:
    name: Install ALB Controller & Deploy App
    runs-on: ubuntu-latest
    needs: build
    outputs:
      alb_url: ${{ steps.alb.outputs.alb_hostname }}

    env:
      IMAGE_URI: ${{ needs.build.outputs.image_uri }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.0

      - name: Setup Terraform (for reading outputs format)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Download TF outputs artifact
        uses: actions/download-artifact@v4
        with:
          name: tf-outputs

      - name: Parse ALB IRSA Role ARN from outputs
        id: tfout
        run: |
          sudo apt-get update -y && sudo apt-get install -y jq
          echo "ALB_ROLE_ARN=$(jq -r '.alb_controller_role_arn.value' tf-outputs.json)" >> $GITHUB_ENV

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region "$AWS_REGION" --name "$CLUSTER_NAME"

      - name: Wait for nodes Ready
        run: |
          # Wait up to ~5 minutes for nodes to join and be Ready
          for i in {1..30}; do
            if kubectl get nodes 2>/dev/null | grep -q ' Ready '; then
              echo "Nodes are Ready"
              kubectl get nodes -o wide
              break
            fi
            echo "Waiting for nodes to become Ready..."
            sleep 10
          done

      # --- Install AWS Load Balancer Controller (no Helm) ---
      - name: Download ALB Controller manifest
        run: |
          curl -L -o v2_7_1_full.yaml \
            https://github.com/kubernetes-sigs/aws-load-balancer-controller/releases/download/v2.7.1/v2_7_1_full.yaml
          # Replace placeholder cluster name in the manifest
          sed -i "s/your-cluster-name/${CLUSTER_NAME}/" v2_7_1_full.yaml

      - name: Apply ALB Controller manifest
        run: kubectl apply -f v2_7_1_full.yaml

      - name: Annotate ALB Controller ServiceAccount with IRSA role
        run: |
          kubectl annotate serviceaccount \
            -n kube-system aws-load-balancer-controller \
            eks.amazonaws.com/role-arn=${ALB_ROLE_ARN} --overwrite

      - name: Restart & Wait for ALB Controller
        run: |
          kubectl -n kube-system rollout restart deployment aws-load-balancer-controller
          kubectl -n kube-system rollout status deployment aws-load-balancer-controller --timeout=300s

      # --- Deploy app manifests ---
      - name: Apply Deployment, Service, Ingress
        run: |
          kubectl apply -f k8s/deployment.yml
          kubectl apply -f k8s/service.yml
          kubectl apply -f k8s/ingress.yml

      - name: Update Deployment image to latest ECR build
        run: |
          echo "Setting image to: ${IMAGE_URI}"
          kubectl set image deployment/nginx-deployment nginx="${IMAGE_URI}"
          kubectl rollout status deployment/nginx-deployment --timeout=300s

      - name: Get ALB Address
        id: alb
        run: |
          # Wait up to ~10 minutes for Ingress to provision an ALB and get a hostname
          for i in {1..60}; do
            ENDPOINT=$(kubectl get ingress nginx-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)
            if [ -n "$ENDPOINT" ] && [ "$ENDPOINT" != "<nil>" ]; then
              echo "alb_hostname=$ENDPOINT" >> $GITHUB_ENV
              echo "alb_hostname=$ENDPOINT" >> $GITHUB_OUTPUT
              break
            fi
            echo "Waiting for ALB hostname..."
            sleep 10
          done
          echo "### üåê ALB DNS Hostname" >> $GITHUB_STEP_SUMMARY
          echo "\`${ENDPOINT}\`" >> $GITHUB_STEP_SUMMARY

      - name: Test NGINX endpoint
        run: |
          echo "Testing NGINX endpoint at: $alb_hostname"
          for i in {1..30}; do
            if curl -s --fail "http://$alb_hostname" >/dev/null; then
              echo "‚úÖ NGINX is up and serving traffic!"
              exit 0
            fi
            echo "Retrying in 10s..."
            sleep 10
          done
          echo "‚ùå NGINX did not become ready in time"
          exit 1
